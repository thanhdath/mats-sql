You are SQL Tutor that validates the student query. Given a database schema, a question, and SQL query generated by student and its response in database. Check each part of the query and point out if it's correct or not. A condition must have left hand side and right hand side, for example "A = B", "A in [1,2]". This is not a condition ```movie_popularity```, do not generate condition like this example.
database schema :
table movies , columns = [ movies.movie_release_year ( integer | values : 2007 , 2006 ) , movies.movie_title ( text | values : La Antena , Elementary Particles ) , movies.movie_popularity ( integer | values : 105 , 23 ) , movies.movie_id ( integer | primary key | values : 1 , 2 ) , movies.movie_title_language ( text | values : en ) , movies.director_name ( text | values : Esteban Sapir , Oskar Roehler ) , movies.movie_url ( text ) , movies.movie_image_url ( text ) , movies.director_id ( text | values : 131 , 73 ) , movies.director_url ( text ) ]
table ratings_users , columns = [ ratings_users.user_id ( integer | values : 41579158 , 68654088 ) , ratings_users.user_subscriber ( integer | values : 0 , 1 ) , ratings_users.user_trialist ( integer | values : 0 , 1 ) , ratings_users.user_has_payment_method ( integer | values : 0 , 1 ) , ratings_users.rating_date_utc ( text | values : 2017-06-10 , 2012-10-02 ) , ratings_users.user_cover_image_url ( text ) , ratings_users.user_eligible_for_trial ( integer | values : 1 , 0 ) , ratings_users.user_avatar_image_url ( text ) ]
table lists_users , columns = [ lists_users.list_id ( integer | primary key | values : 192287 , 192313 ) , lists_users.user_id ( integer | primary key | values : 2385 , 15264 ) , lists_users.user_trialist ( integer | values : 1 , 0 ) , lists_users.user_has_payment_method ( text | values : 1 , 0 ) , lists_users.user_subscriber ( integer | values : 1 , 0 ) , lists_users.user_eligible_for_trial ( text | values : 0 , 1 ) , lists_users.user_cover_image_url ( text ) , lists_users.user_avatar_image_url ( text ) , lists_users.list_creation_date_utc ( text | values : 2009-12-18 , 2010-01-30 ) , lists_users.list_update_date_utc ( text | values : 2019-11-26 , 2020-05-01 ) ]
table lists , columns = [ lists.list_title ( text | values : Headscratchers ) , lists.list_movie_number ( integer | values : 5 , 3 ) , lists.list_id ( integer | primary key | values : 1 , 2 ) , lists.user_id ( integer | values : 88260493 , 45204418 ) , lists.list_description ( text ) , lists.list_comments ( integer | values : 3 , 2 ) , lists.list_url ( text ) , lists.list_followers ( integer | values : 5 , 1 ) , lists.list_third_image_url ( text ) , lists.list_second_image_url ( text ) ]
table ratings , columns = [ ratings.movie_id ( integer | values : 1066 , 1067 ) , ratings.rating_id ( integer | values : 15610495 , 10704606 ) , ratings.critic ( text ) , ratings.user_id ( integer | values : 41579158 , 85981819 ) , ratings.rating_score ( integer | values : 3 , 2 ) , ratings.critic_comments ( integer | values : 0 , 2 ) , ratings.critic_likes ( integer | values : 0 , 1 ) , ratings.rating_url ( text ) , ratings.user_trialist ( integer | values : 0 , 1 ) , ratings.user_subscriber ( integer | values : 0 , 1 ) ]
foreign keys :
lists.user_id = lists_users.user_id
ratings_users.user_id = lists_users.user_id
lists_users.user_id = lists.user_id
lists_users.list_id = lists.list_id
ratings.user_id = ratings_users.user_id
ratings.rating_id = ratings.rating_id
ratings.user_id = lists_users.user_id
ratings.movie_id = movies.movie_id

Matched contents are written in this format table.column (some values can be found in that column)
matched contents :
movies.movie_release_year ( 1945 )
movies.movie_title ( Year , 1945 , Order , The Years , Release )
movies.movie_id ( 1945 )
lists_users.list_id ( 1945 )
lists.list_title ( 1945 , Sort , Titles. , title , Title )
lists.list_id ( 1945 )
ratings.movie_id ( 1945 )
ratings.rating_id ( 1945 )

Question: Sort the listing by the descending order of movie popularity.
External knowledge: released in the year 1945 refers to movie_release_year = 1945; Name movie titles released in year 1945.

SQL query: SELECT movie_title FROM movies WHERE movie_release_year = 1945 ORDER BY movie_popularity DESC LIMIT 1

Execution response [written in pandas format].
       movie_title
0  Brief Encounter

Feedback:
CONDITION.
- The query uses:
   1. Condition in SELECT ```None```.
   2. Condition in WHERE ```movie_release_year = 1945```. This filter the movie released in year 1945.
   3. Condition in ORDER BY ```None```.
- Based on the question:
   1. 'movie titles released in year 1945': from external knowledge `released in the year 1945`, so this refers to the condition ```movies.movie_release_year = 1945```. The query used this condition in WHERE.
- Therefore, the query used correct conditions.
- Conclude: correct.
=========
database schema:
table frpm , columns = [
  `free meal count (k-12)` | type: real ; has None value ; values: 565.0 , 186.0
  cdscode | primary key ; type: text ; values: 01100170109835 , 01100170112607
  `enrollment (k-12)` | type: real ; values: 1087.0 , 395.0
  `county name` | type: text ; values: Alameda , Alpine
  `county code` | type: text ; values: 01 , 02
  `percent (%) eligible free (k-12)` | type: real ; has None value ; values: 0.519779208831647 , 0.470886075949367
  `district code` | type: integer ; values: 10017 , 31609
  `district name` | type: text
  `school code` | type: text ; values: 0109835 , 0112607
  `free meal count (ages 5-17)` | type: real ; has None value ; values: 553.0 , 182.0
]
table schools , columns = [
  cdscode | primary key ; type: text ; values: 01100170000000 , 01100170109835
  soc | type: text ; meaning: school ownership code ; has None value ; values: 65 , 66
  county | type: text ; values: Alameda , Alpine
  soctype | type: text ; meaning: school ownership code type ; has None value ; values: K-12 Schools (Public) , High Schools (Public)
  district | type: text
  state | type: text ; has None value ; values: CA
  school | type: text ; has None value ; values: FAME Public Charter
  ncesdist | type: text ; meaning: national center for educational statistics school district identification number ; has None value ; values: 0691051 , 0600002
  edopscode | type: text ; meaning: education option code ; has None value ; values: TRAD , JUV
  ncesschool | type: text ; meaning: national center for educational statistics school identification number ; has None value ; values: 10546 , 10947
]
table satscores , columns = [
  dname | type: text ; meaning: district name ; values: Alameda Unified
  cname | type: text ; meaning: county name ; values: Alameda , Amador
  enroll12 | type: integer ; meaning: enrollment (1st-12nd grade) ; values: 398 , 62
  sname | type: text ; meaning: school name ; has None value ; values: FAME Public Charter
  cds | primary key ; type: text ; values: 10101080000000 , 10101080109991
  numtsttakr | type: integer ; meaning: number of test takers ; values: 88 , 17
  numge1500 | type: integer ; meaning: number of test takers whose total sat scores are greater or equal to 1500 ; has None value ; values: 14 , 9
  rtype | type: text ; values: D , S
  avgscrmath | type: integer ; meaning: average scores in math ; has None value ; values: 418 , 546
  avgscrread | type: integer ; meaning: average scores in reading ; has None value ; values: 418 , 503
]
foreign keys:
frpm.cdscode = schools.cdscode
satscores.cds = schools.cdscode

Matched contents are written in this format table.column (some values can be found in that column)
matched contents :
frpm.`educational option type` ( Continuation School )
schools.school ( Continuation School )
schools.edopsname ( Continuation School )

Question: Please list the lowest three eligible free rates for students aged 5-17 in continuation schools.
External knowledge: Eligible free rates for students aged 5-17 = `free meal count (ages 5-17)` / `enrollment (ages 5-17)`;

SQL query: SELECT frpm.`free meal count (ages 5-17)` / frpm.`enrollment (ages 5-17)`
FROM frpm
INNER JOIN schools ON frpm.cdscode = schools.cdscode
WHERE schools.edopsname = 'Continuation School'
ORDER BY frpm.`free meal count (ages 5-17)` / frpm.`enrollment (ages 5-17)` ASC
LIMIT 3;

Execution response [written in pandas format].
frpm.`free meal count (ages 5-17)` / frpm.`enrollment (ages 5-17)`
0                                               None
1                                               None
2                                               None

Feedback:
CONDITION.
- The query uses:
   1. Condition in SELECT ```frpm.`free meal count (ages 5-17)` / frpm.`enrollment (ages 5-17)``` which calculates the eligible free rate for students aged 5-17.
   2. Condition in WHERE ```schools.edopsname = 'Continuation School'```. This filters for continuation schools.
   3. Condition in ORDER BY ```frpm.`free meal count (ages 5-17)` / frpm.`enrollment (ages 5-17)` ASC```. This orders the results by the calculated eligible free rate in ascending order.

- Based on the question:
   1. 'lowest three eligible free rates for students aged 5-17': The query correctly calculates the eligible free rates using the formula provided in the external knowledge.
   2. 'in continuation schools': The query correctly filters for continuation schools using the condition in WHERE.

- However, the execution response shows that all values returned are `None`. The SQL query should include a check for `None` values in the `free meal count (ages 5-17)` and `enrollment (ages 5-17)` columns.

- Conclude: incorrect.
=========
database schema:
table schools , columns = [
  magnet | type: integer ; has None value ; values: 0 , 1
  cdscode | primary key ; type: text ; values: 01100170000000 , 01100170109835
  school | type: text ; has None value ; values: FAME Public Charter
  ncesdist | type: text ; meaning: national center for educational statistics school district identification number ; has None value ; values: 0691051 , 0600002
  soctype | type: text ; meaning: school ownership code type ; has None value ; values: K-12 Schools (Public) , High Schools (Public)
  charternum | type: text ; has None value ; values: 0728 , 0811
  ncesschool | type: text ; meaning: national center for educational statistics school identification number ; has None value ; values: 10546 , 10947
  district | type: text
  charter | type: integer ; has None value ; values: 1 , 0
  fundingtype | type: text ; has None value ; values: Directly funded , Locally funded
]
table satscores , columns = [
  cds | primary key ; type: text ; values: 10101080000000 , 10101080109991
  sname | type: text ; meaning: school name ; has None value ; values: FAME Public Charter
  dname | type: text ; meaning: district name ; values: Alameda Unified
  rtype | type: text ; values: D , S
  numtsttakr | type: integer ; meaning: number of test takers ; values: 88 , 17
  numge1500 | type: integer ; meaning: number of test takers whose total sat scores are greater or equal to 1500 ; has None value ; values: 14 , 9
  cname | type: text ; meaning: county name ; values: Alameda , Amador
  enroll12 | type: integer ; meaning: enrollment (1st-12nd grade) ; values: 398 , 62
  avgscrread | type: integer ; meaning: average scores in reading ; has None value ; values: 418 , 503
  avgscrmath | type: integer ; meaning: average scores in math ; has None value ; values: 418 , 546
]
table frpm , columns = [
  cdscode | primary key ; type: text ; values: 01100170109835 , 01100170112607
  `school name` | type: text ; values: FAME Public Charter
  `school type` | type: text ; has None value ; values: K-12 Schools (Public) , High Schools (Public)
  `district name` | type: text
  `school code` | type: text ; values: 0109835 , 0112607
  `district type` | type: text ; values: State Special Schools
  `educational option type` | type: text ; has None value ; values: Traditional , Juvenile Court School
  `2013-14 calpads fall 1 certification status` | type: integer ; values: 1
  `district code` | type: integer ; values: 10017 , 31609
  `nslp provision status` | type: text ; has None value ; values: Breakfast Provision 2 , Provision 2
]
foreign keys:
frpm.cdscode = schools.cdscode
satscores.cds = schools.cdscode

Matched contents are written in this format table.column (some values can be found in that column)
matched contents :
satscores.numge1500 ( 500 )
satscores.enroll12 ( 500 )
satscores.avgscrread ( 500 )
satscores.avgscrmath ( 500 )

Question: Among the schools with the SAT test takers of over 500, please list the schools that are magnet schools or offer a magnet program.
External knowledge: magnet schools or offer a magnet program means that magnet = 1;

SQL query: SELECT schools.school 
FROM satscores 
INNER JOIN schools ON satscores.cds = schools.cdscode 
WHERE satscores.numge1500 > 500 
AND schools.magnet = 1;

Execution response [written in pandas format].
Empty DataFrame
Columns: [School]
Index: []

If the execution response empty response, it is incorrect. Add your thought to the end of the feedback to modify the query.
If the execution response is correct, the SQL query is correct.

Feedback:
CONDITION.
- The query uses:
   1. Condition in SELECT ```schools.school```. This selects the school names from the `schools` table.
   2. Condition in WHERE ```satscores.numge1500 > 500 AND schools.magnet = 1```. This filters for schools with more than 500 SAT test takers and that are magnet schools or offer a magnet program.

- Based on the question:
   1. 'schools with the SAT test takers of over 500': The query correctly filters for schools with SAT test takers greater than 500 using the condition ```satscores.numge1500 > 500```.
   2. 'magnet schools or offer a magnet program': The query correctly filters for magnet schools using the condition ```schools.magnet = 1```.

- However, the execution response shows that the result is an empty DataFrame. The SQL query should checks for schools that are either classified as magnet schools or have a school type that includes "magnet" in its description (schools.magnet = 1 OR schools.soctype LIKE '%magnet%').

- Conclude: incorrect.
